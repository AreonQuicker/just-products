type AggregateProduct {
  count: Int!
}

type AggregateProductSegment {
  count: Int!
}

type AggregateSegment {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductSegment(data: ProductSegmentCreateInput!): ProductSegment!
  updateProductSegment(data: ProductSegmentUpdateInput!, where: ProductSegmentWhereUniqueInput!): ProductSegment
  updateManyProductSegments(data: ProductSegmentUpdateManyMutationInput!, where: ProductSegmentWhereInput): BatchPayload!
  upsertProductSegment(where: ProductSegmentWhereUniqueInput!, create: ProductSegmentCreateInput!, update: ProductSegmentUpdateInput!): ProductSegment!
  deleteProductSegment(where: ProductSegmentWhereUniqueInput!): ProductSegment
  deleteManyProductSegments(where: ProductSegmentWhereInput): BatchPayload!
  createSegment(data: SegmentCreateInput!): Segment!
  updateSegment(data: SegmentUpdateInput!, where: SegmentWhereUniqueInput!): Segment
  updateManySegments(data: SegmentUpdateManyMutationInput!, where: SegmentWhereInput): BatchPayload!
  upsertSegment(where: SegmentWhereUniqueInput!, create: SegmentCreateInput!, update: SegmentUpdateInput!): Segment!
  deleteSegment(where: SegmentWhereUniqueInput!): Segment
  deleteManySegments(where: SegmentWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  itemCode: String!
  baseItemCode: String!
  colourCode: String
  sizeCode: String
  segments(where: ProductSegmentWhereInput, orderBy: ProductSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductSegment!]
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  itemCode: String!
  baseItemCode: String!
  colourCode: String
  sizeCode: String
  segments: ProductSegmentCreateManyWithoutProductInput
}

input ProductCreateOneWithoutSegmentsInput {
  create: ProductCreateWithoutSegmentsInput
  connect: ProductWhereUniqueInput
}

input ProductCreateWithoutSegmentsInput {
  id: ID
  itemCode: String!
  baseItemCode: String!
  colourCode: String
  sizeCode: String
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  itemCode_ASC
  itemCode_DESC
  baseItemCode_ASC
  baseItemCode_DESC
  colourCode_ASC
  colourCode_DESC
  sizeCode_ASC
  sizeCode_DESC
}

type ProductPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  itemCode: String!
  baseItemCode: String!
  colourCode: String
  sizeCode: String
}

type ProductSegment {
  id: ID!
  code: String!
  segment: Segment!
  product: Product!
}

type ProductSegmentConnection {
  pageInfo: PageInfo!
  edges: [ProductSegmentEdge]!
  aggregate: AggregateProductSegment!
}

input ProductSegmentCreateInput {
  id: ID
  code: String!
  segment: SegmentCreateOneWithoutProductsInput!
  product: ProductCreateOneWithoutSegmentsInput!
}

input ProductSegmentCreateManyWithoutProductInput {
  create: [ProductSegmentCreateWithoutProductInput!]
  connect: [ProductSegmentWhereUniqueInput!]
}

input ProductSegmentCreateManyWithoutSegmentInput {
  create: [ProductSegmentCreateWithoutSegmentInput!]
  connect: [ProductSegmentWhereUniqueInput!]
}

input ProductSegmentCreateWithoutProductInput {
  id: ID
  code: String!
  segment: SegmentCreateOneWithoutProductsInput!
}

input ProductSegmentCreateWithoutSegmentInput {
  id: ID
  code: String!
  product: ProductCreateOneWithoutSegmentsInput!
}

type ProductSegmentEdge {
  node: ProductSegment!
  cursor: String!
}

enum ProductSegmentOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
}

type ProductSegmentPreviousValues {
  id: ID!
  code: String!
}

input ProductSegmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  AND: [ProductSegmentScalarWhereInput!]
  OR: [ProductSegmentScalarWhereInput!]
  NOT: [ProductSegmentScalarWhereInput!]
}

type ProductSegmentSubscriptionPayload {
  mutation: MutationType!
  node: ProductSegment
  updatedFields: [String!]
  previousValues: ProductSegmentPreviousValues
}

input ProductSegmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductSegmentWhereInput
  AND: [ProductSegmentSubscriptionWhereInput!]
  OR: [ProductSegmentSubscriptionWhereInput!]
  NOT: [ProductSegmentSubscriptionWhereInput!]
}

input ProductSegmentUpdateInput {
  code: String
  segment: SegmentUpdateOneRequiredWithoutProductsInput
  product: ProductUpdateOneRequiredWithoutSegmentsInput
}

input ProductSegmentUpdateManyDataInput {
  code: String
}

input ProductSegmentUpdateManyMutationInput {
  code: String
}

input ProductSegmentUpdateManyWithoutProductInput {
  create: [ProductSegmentCreateWithoutProductInput!]
  delete: [ProductSegmentWhereUniqueInput!]
  connect: [ProductSegmentWhereUniqueInput!]
  set: [ProductSegmentWhereUniqueInput!]
  disconnect: [ProductSegmentWhereUniqueInput!]
  update: [ProductSegmentUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ProductSegmentUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ProductSegmentScalarWhereInput!]
  updateMany: [ProductSegmentUpdateManyWithWhereNestedInput!]
}

input ProductSegmentUpdateManyWithoutSegmentInput {
  create: [ProductSegmentCreateWithoutSegmentInput!]
  delete: [ProductSegmentWhereUniqueInput!]
  connect: [ProductSegmentWhereUniqueInput!]
  set: [ProductSegmentWhereUniqueInput!]
  disconnect: [ProductSegmentWhereUniqueInput!]
  update: [ProductSegmentUpdateWithWhereUniqueWithoutSegmentInput!]
  upsert: [ProductSegmentUpsertWithWhereUniqueWithoutSegmentInput!]
  deleteMany: [ProductSegmentScalarWhereInput!]
  updateMany: [ProductSegmentUpdateManyWithWhereNestedInput!]
}

input ProductSegmentUpdateManyWithWhereNestedInput {
  where: ProductSegmentScalarWhereInput!
  data: ProductSegmentUpdateManyDataInput!
}

input ProductSegmentUpdateWithoutProductDataInput {
  code: String
  segment: SegmentUpdateOneRequiredWithoutProductsInput
}

input ProductSegmentUpdateWithoutSegmentDataInput {
  code: String
  product: ProductUpdateOneRequiredWithoutSegmentsInput
}

input ProductSegmentUpdateWithWhereUniqueWithoutProductInput {
  where: ProductSegmentWhereUniqueInput!
  data: ProductSegmentUpdateWithoutProductDataInput!
}

input ProductSegmentUpdateWithWhereUniqueWithoutSegmentInput {
  where: ProductSegmentWhereUniqueInput!
  data: ProductSegmentUpdateWithoutSegmentDataInput!
}

input ProductSegmentUpsertWithWhereUniqueWithoutProductInput {
  where: ProductSegmentWhereUniqueInput!
  update: ProductSegmentUpdateWithoutProductDataInput!
  create: ProductSegmentCreateWithoutProductInput!
}

input ProductSegmentUpsertWithWhereUniqueWithoutSegmentInput {
  where: ProductSegmentWhereUniqueInput!
  update: ProductSegmentUpdateWithoutSegmentDataInput!
  create: ProductSegmentCreateWithoutSegmentInput!
}

input ProductSegmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  segment: SegmentWhereInput
  product: ProductWhereInput
  AND: [ProductSegmentWhereInput!]
  OR: [ProductSegmentWhereInput!]
  NOT: [ProductSegmentWhereInput!]
}

input ProductSegmentWhereUniqueInput {
  id: ID
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  itemCode: String
  baseItemCode: String
  colourCode: String
  sizeCode: String
  segments: ProductSegmentUpdateManyWithoutProductInput
}

input ProductUpdateManyMutationInput {
  itemCode: String
  baseItemCode: String
  colourCode: String
  sizeCode: String
}

input ProductUpdateOneRequiredWithoutSegmentsInput {
  create: ProductCreateWithoutSegmentsInput
  update: ProductUpdateWithoutSegmentsDataInput
  upsert: ProductUpsertWithoutSegmentsInput
  connect: ProductWhereUniqueInput
}

input ProductUpdateWithoutSegmentsDataInput {
  itemCode: String
  baseItemCode: String
  colourCode: String
  sizeCode: String
}

input ProductUpsertWithoutSegmentsInput {
  update: ProductUpdateWithoutSegmentsDataInput!
  create: ProductCreateWithoutSegmentsInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  itemCode: String
  itemCode_not: String
  itemCode_in: [String!]
  itemCode_not_in: [String!]
  itemCode_lt: String
  itemCode_lte: String
  itemCode_gt: String
  itemCode_gte: String
  itemCode_contains: String
  itemCode_not_contains: String
  itemCode_starts_with: String
  itemCode_not_starts_with: String
  itemCode_ends_with: String
  itemCode_not_ends_with: String
  baseItemCode: String
  baseItemCode_not: String
  baseItemCode_in: [String!]
  baseItemCode_not_in: [String!]
  baseItemCode_lt: String
  baseItemCode_lte: String
  baseItemCode_gt: String
  baseItemCode_gte: String
  baseItemCode_contains: String
  baseItemCode_not_contains: String
  baseItemCode_starts_with: String
  baseItemCode_not_starts_with: String
  baseItemCode_ends_with: String
  baseItemCode_not_ends_with: String
  colourCode: String
  colourCode_not: String
  colourCode_in: [String!]
  colourCode_not_in: [String!]
  colourCode_lt: String
  colourCode_lte: String
  colourCode_gt: String
  colourCode_gte: String
  colourCode_contains: String
  colourCode_not_contains: String
  colourCode_starts_with: String
  colourCode_not_starts_with: String
  colourCode_ends_with: String
  colourCode_not_ends_with: String
  sizeCode: String
  sizeCode_not: String
  sizeCode_in: [String!]
  sizeCode_not_in: [String!]
  sizeCode_lt: String
  sizeCode_lte: String
  sizeCode_gt: String
  sizeCode_gte: String
  sizeCode_contains: String
  sizeCode_not_contains: String
  sizeCode_starts_with: String
  sizeCode_not_starts_with: String
  sizeCode_ends_with: String
  sizeCode_not_ends_with: String
  segments_every: ProductSegmentWhereInput
  segments_some: ProductSegmentWhereInput
  segments_none: ProductSegmentWhereInput
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productSegment(where: ProductSegmentWhereUniqueInput!): ProductSegment
  productSegments(where: ProductSegmentWhereInput, orderBy: ProductSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductSegment]!
  productSegmentsConnection(where: ProductSegmentWhereInput, orderBy: ProductSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductSegmentConnection!
  segment(where: SegmentWhereUniqueInput!): Segment
  segments(where: SegmentWhereInput, orderBy: SegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Segment]!
  segmentsConnection(where: SegmentWhereInput, orderBy: SegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SegmentConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Segment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  rule: String!
  products(where: ProductSegmentWhereInput, orderBy: ProductSegmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductSegment!]
}

type SegmentConnection {
  pageInfo: PageInfo!
  edges: [SegmentEdge]!
  aggregate: AggregateSegment!
}

input SegmentCreateInput {
  id: ID
  rule: String!
  products: ProductSegmentCreateManyWithoutSegmentInput
}

input SegmentCreateOneWithoutProductsInput {
  create: SegmentCreateWithoutProductsInput
  connect: SegmentWhereUniqueInput
}

input SegmentCreateWithoutProductsInput {
  id: ID
  rule: String!
}

type SegmentEdge {
  node: Segment!
  cursor: String!
}

enum SegmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  rule_ASC
  rule_DESC
}

type SegmentPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  rule: String!
}

type SegmentSubscriptionPayload {
  mutation: MutationType!
  node: Segment
  updatedFields: [String!]
  previousValues: SegmentPreviousValues
}

input SegmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SegmentWhereInput
  AND: [SegmentSubscriptionWhereInput!]
  OR: [SegmentSubscriptionWhereInput!]
  NOT: [SegmentSubscriptionWhereInput!]
}

input SegmentUpdateInput {
  rule: String
  products: ProductSegmentUpdateManyWithoutSegmentInput
}

input SegmentUpdateManyMutationInput {
  rule: String
}

input SegmentUpdateOneRequiredWithoutProductsInput {
  create: SegmentCreateWithoutProductsInput
  update: SegmentUpdateWithoutProductsDataInput
  upsert: SegmentUpsertWithoutProductsInput
  connect: SegmentWhereUniqueInput
}

input SegmentUpdateWithoutProductsDataInput {
  rule: String
}

input SegmentUpsertWithoutProductsInput {
  update: SegmentUpdateWithoutProductsDataInput!
  create: SegmentCreateWithoutProductsInput!
}

input SegmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  rule: String
  rule_not: String
  rule_in: [String!]
  rule_not_in: [String!]
  rule_lt: String
  rule_lte: String
  rule_gt: String
  rule_gte: String
  rule_contains: String
  rule_not_contains: String
  rule_starts_with: String
  rule_not_starts_with: String
  rule_ends_with: String
  rule_not_ends_with: String
  products_every: ProductSegmentWhereInput
  products_some: ProductSegmentWhereInput
  products_none: ProductSegmentWhereInput
  AND: [SegmentWhereInput!]
  OR: [SegmentWhereInput!]
  NOT: [SegmentWhereInput!]
}

input SegmentWhereUniqueInput {
  id: ID
}

type Subscription {
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productSegment(where: ProductSegmentSubscriptionWhereInput): ProductSegmentSubscriptionPayload
  segment(where: SegmentSubscriptionWhereInput): SegmentSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  surname: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  surname: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  surname_ASC
  surname_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  surname: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  surname: String
}

input UserUpdateManyMutationInput {
  name: String
  surname: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  surname: String
  surname_not: String
  surname_in: [String!]
  surname_not_in: [String!]
  surname_lt: String
  surname_lte: String
  surname_gt: String
  surname_gte: String
  surname_contains: String
  surname_not_contains: String
  surname_starts_with: String
  surname_not_starts_with: String
  surname_ends_with: String
  surname_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
